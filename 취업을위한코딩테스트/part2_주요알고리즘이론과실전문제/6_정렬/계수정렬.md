# 계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘
- 데이터가 모두 양의 정수이며, 데이터의 개수가 N, 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행시간 $O(N+K)$을 보장함
- 매우 빠르게 동작하며, 매우 간단한 원리
- 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능
- 실수형 데이터로 주어질 때 사용하기 어려움
- 일반적으로는 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적
- 데이터의 범위가 너무 크면 계수정렬을 사용할 수 없음. 
- 계수정렬을 이용할 때에는 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언하기 때문
- 계수 정렬은 비교 기반의 정렬 알고리즘이 아니다. 
  

계수정렬 소스코드
```python
# SOLUTION
def sorting(arr):
    a, b = min(arr), max(arr)
    cnt_list = [0 for _ in range(b-a+1)]

    for v in arr:
        cnt_list[v-a] += 1
    
    sorted_list = []
    for i in range(b-a+1):
        for _ in range(cnt_list[i]):
            sorted_list.append(a+i)
    
    return sorted_list
```

### 시간복잡도
- 데이터가 정수, 데이터의 개수가 N, 최대값이 K일 때, $O(N+K)$
- 데이터를 하나씩 확인하면서 최소, 최댓값을 확인하며, 인덱스의 값을 1씩 증가시키는 동작을 하며, 리스트의 각 인덱스에 해당하는 값들을 확인할 때 최댓값의 크기만큼 반복 수행하기 때문
- 사실 상 현존하는 정렬 알고리즘 중 기수 정렬과 더불어 가장 빠르다. 

### 공간복잡도
- 때에 따라 심각한 비효율성을 초래할 수도 있음. (ex. 데이터가 0과 999,999 만 있을 때)
- 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합 (ex. 성적)
- 크기가 한정되어 있고, 데이터가 많이 중복되어 있을수록 유리