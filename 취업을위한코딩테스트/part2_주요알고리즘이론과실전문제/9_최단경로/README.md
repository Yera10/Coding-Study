# 최단 경로

- 가장 짧은 경로를 찾는 알고리즘, <u>"길찾기" 문제</u>라고도 불림.
- 최단 경로 알고리즘 유형에도 다양한 종류가 있음. 
  - 예를 들어 '한 지점에서 다른 특정 지점까지의 최단 경로 구하기'
  - 또는 '모든 지점에서 다른 모든 지점까지의 최단 경로 구하기' 등..
- 최단 경로 문제는 <u>보통 그래프를 이용해 표현</u>하며, 그래프는 "노드"와 "간선"으로 구성된다. 

### 최단 거리 알고리즘
1. 다익스트라 최단 경로
2. 플로이드 워셜
3. 벨만 포드 알고리즘

(최단 거리 알고리즘은 그리디, 다이나믹 프로그래밍 알고리즘의 한 유형이다.)

### 다익스트라 최단 경로
- 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
- '음의 간선'이 없을 때 정상적으로 동작됨\
('음의 간선': 0보다 작은 값을 가지는 간선)
- 현실세계의 길은 음의 간선으로 표현되지 않기 때문에 <u>실제로 GPS 소프트웨어 기본 알고리즘</u>으로 채택됨
- 그리디 알고리즘으로 분류

### 다익스트라 최단 경로의 순서
1. 출발 노드 설정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중 최단거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
5. 3,4번을 반복

### 다익스트라 최단 경로의 특징
- 최단 경로를 구하는 과정에서 <u>'각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차원 리스트에 저장</u>하며 리스트를 계속 갱신
- 매번 현재 처리하고 있는 노드를 기준으로 주변 간선 확인
- 데이크스트라와 같은 알고리즘
- **방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복**
  - 위 과정에서 선택된 노드는 '최단거리'가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다. (>>정말?)
  - \>\>한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있음. 
  - \> 그렇기 때문에 사실 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우를 확인할 필요가 없다. 

다익스트라 소스코드
```python
INF = int(1e9)

def Dijkstra(g, N, start):
    distance = [0] + [INF] * (N-1)
    not_visited = {i for i in range(N)}
    
    while not_visited:
        # 최단거리가 가장 짧은 노드 선택
        v = -1       
        mind = INF
        for nv in not_visited:
            if distance[nv] < mind:
                v = nv
                mind = distance[nv]
        not_visited.remove(v)
        
        # 최단거리 테이블 갱신
        for i,d in enumerate(g[v]):
            if (d != -1) and (mind + d < distance[i]):
                distance[i] = mind + d
    
    return distance

# TEST
N = 6
g = [
    [0, 2, 5, 1, -1, -1],
    [-1, 0, 3, 2, -1, -1], 
    [-1, 3, 0, -1, -1, 5], 
    [-1, -1, 3, 0, 1, -1], 
    [-1, -1, 1, -1, 0, 2],
    [-1, -1, -1, -1, -1, 0]
]
print(Dijkstra(g, N, 1))
```
