# 모험가 길드

### **Input**
- N : 모험가의 수
- arr : 각 모험가의 공포도 값 (각 값은 N 이하)

### 방법
- 공포도가 X인 모험가는 반드시 X명 이상의 그룹에 속해야 한다. 

### **Output**
- 떠날 수 있는 그룹 수의 최댓값

### **입력과 출력 예**
| N | arr | result |
|---|---|--------|
| 5 | 2 3 1 2 2 | 2 |


### **나의 풀이 코드**
```python
def solution(N, arr):
    arr.sort()
    group = 0
    
    n = 0
    maxa = 0
    for a in arr:
        n += 1
        if a > maxa:
            maxa = a
        if n >= maxa:
            n = 0
            maxa = 0
            group += 1
    
    return group
```
- $O(nlogn)$<br>
  - $n$ : arr의 길이
- 그룹에 어떻게 모험가를 배정해야 최대 그룹을 뽑을 수 있는지 생각해야 했음. 
- 그룹 수를 최대로 한다\
$\Rightarrow$ 각 그룹의 모험가 수를 최소로 한다.\
$\Rightarrow$ 공포도가 작은 순서대로 모험가를 같은 그룹에 배정한다.\
- a, b 공포도를 가진 모험가가 있고 (a < b), a 모험가는 b가 없이 b보다 적은 인원의 그룹에 참여할 수 있다고 가정하자. 이때, a는 다른 그룹에 참여하는 게 좋을까?\
b와 같은 그룹에 참여하는 게 좋을까? 그룹의 모험가 수를 최소로 하는 게 좋기 때문에 당연히 다른 그룹에 참여하는 게 좋을 것 같다. 이거에도 정당화가 필요하다.\
a가 다른 그룹에 참여했을 때, 더 안좋아진다고 볼 수 있는 것은 b가 a가 없어서 그룹을 이루지 못한 경우다. 만약, 그 다른 그룹이 a가 있어서 그룹을 이룰 수 있었다면, -1 +1이기 때문에 손해는 아니다. 하지만, a가 없어도 결성될 그룹이었다면? 분명 손해겠지만, 그렇다면 그 그룹에서 공포도가 가장 큰 모험가를 b가 속한 그룹에 내어주면, 두 그룹 모두 유지되기 때문에 손해는 아니다. 이렇게 할 수 있다고 생각한 이유는 모험가가 작은 순서대로 그룹을 결성하기 위해서이다. \
$\Rightarrow$ 공포도가 작은 순서대로 그룹을 결성할 수 있다.  

  
### **더 좋은 풀이 코드**
```python
n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0 # 총 그룹의 수
count = 0 # 현재 그룹에 포함된 모험가의 수

for i in data: # 공포도를 낮은 것부터 하나씩 확인하며
    count += 1 # 현재 그룹에 해당 모험가를 포함시키기
    if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
        result += 1 # 총 그룹의 수 증가시키기
        count = 0 # 현재 그룹에 포함된 모험가의 수 초기화

print(result) # 총 그룹의 수 출력
```
- $O(nlogn)$<br>
  - $n$ : arr의 길이
- sort 해서 항상 마지막 값이 최대이므로 최대값을 계산할 필요가 없다. 