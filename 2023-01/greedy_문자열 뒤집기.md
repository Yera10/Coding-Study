# 문자열 뒤집기

### **Input**
- 0과 1로만 이루어진 문자열 S

### **Output**
- 행동 : 문자열 S에서 연속된 하나 이상의 숫자를 모두 뒤집는 것
- S에 있는 모든 숫자를 전부 같게 만들기 위해 필요한 최소한의 행동 횟수 return 

### **입력과 출력 예**
| S | result |
|---|--------|
| "0001100"	| 1 |


### **나의 풀이 코드**
```python
def solution(S):
    ch = 0
    for i in range(len(S)-1):
        if S[i]!=S[i+1]:
            ch += 1
    return (ch+1)//2
```
- $O(N)$<br>
  - $N$ : 문자열 $S$의 길이
- 숫자가 모두 같은 범위를 하나의 구간이라고 하기. 
- 구간이 홀수개 일때는 맨 앞 숫자와 맨 뒷 숫자가 같음.
- 문자열의 모든 숫자를 일치시키기 위해서 문자열 안의 구간부터 뒤집어 나가나 앞에서부터 다른 부분을 뒤집어 나가나 똑같다.
- $g(n)$ = 구간이 n개 있을 때, 필요한 최소한의 행동 횟수일때, $g(n) = n//2$
  - $g(2k+1) = k$
    - $f(k+1)$ = 구간이 2n+1개 있을 때, 맨 앞 숫자와 다른 숫자로 통일시키기 위한 최소한의 행동 횟수 라고 하면, $f(2k+1) = f(2k-1) + 1, k>=2$
      - 왜냐하면, 2k+1개의 구간이 있을 때, 두가지로 생각해볼 수 있음. (양 끝 수는 1이라고 가정, 모두 0으로 통일해야 함)
      - 양 끝 두개의 구간을 제외한 모든 구간을 0으로 통일(앞,뒤에서 두번째 구간은 0일 것이기 때문에 f(2k-3)과 같음)시킨 뒤, 양 끝 구간을 한번씩 뒤집는다(2회 행동) $\Rightarrow\,f(2k+1) = f(2k-3)+2$ 
      - 양 끝 두개의 구간을 제외한 모든 구간을 1로 통일(=f(2k-1))시킨 뒤, 전체 구간을 한번 뒤집음 $\Rightarrow\,f(2k+1) = f(2k-1)+1$ 
      - $f(2k+1) = min(\,f(2k-3)+2,\,f(2k-1)+1\,)$이지만,\
      f(1) = 1, f(3) = 2로, f(1)과 f(3)이 1차이 이고, 점화식에 더해지는 수도 1차이 이기 때문에\
      $f(2k+1) = f(2k-1) + 1$과 같음. 
      - 이때, f(2*1-1)=1이기 때문에 $f(2k-1)=k$ 
    - 구간이 $2k+1$개 있을 때, 양 끝 구간은 같은 수일 것이기 때문에 양 끝 구간을 제외한 2k-1개의 구간을 반대로 뒤집으면 되기 때문에 $\Rightarrow\,g(2k+1) = f(2k-1) = k$
  - $g(2k) = k$\
  $\because g(2k) = f(2k-1) = k$
- 음.. 맞나..?
  
### **정답 코드**
```python
data = input()
count0 = 0 # 전부 0으로 바꾸는 경우
count1 = 0 # 전부 1로 바꾸는 경우

# 첫 번째 원소에 대해서 처리
if data[0] == '1':
    count0 += 1
else:
    count1 += 1

# 두 번째 원소부터 모든 원소를 확인하며
for i in range(len(data) - 1):
    if data[i] != data[i + 1]:
        # 다음 수에서 1로 바뀌는 경우
        if data[i + 1] == '1':
            count0 += 1
        # 다음 수에서 0으로 바뀌는 경우
        else:
            count1 += 1

print(min(count0, count1))
```
- $O(N)$<br>
  - $N$ : 문자열 $S$의 길이
